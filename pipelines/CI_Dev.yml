name: CI - Tests And Inspection

on:
  pull_request:
    branches: [ "develop", "main" ]
    paths-ignore:
      - '.github/workflows/**'

# Adicionar permissÃµes para comentar nos PRs
permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  DOTNET_VERSION: "8.0.x"
  ASPNETCORE_ENVIRONMENT: "Test"

jobs:
  # ======================================================
  # 1ï¸âƒ£ BUILD JOB
  # ======================================================
  build:
    runs-on: ubuntu-latest
    container:
      image: mcr.microsoft.com/dotnet/sdk:8.0

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Cache do NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restaurar dependÃªncias
        run: dotnet restore backend.sln

      - name: Compilar projeto
        run: dotnet build backend.sln --no-restore --configuration Release

      - name: Guardar artefactos do build
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            **/bin/Release/
            **/obj/Release/


  # ======================================================
  # 2ï¸âƒ£ UNIT TESTS
  # ======================================================
  unit_tests:
    runs-on: ubuntu-latest
    container:
      image: mcr.microsoft.com/dotnet/sdk:8.0
    needs: build
    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Restaurar dependÃªncias
        run: dotnet restore backend.sln

      - name: Compilar soluÃ§Ã£o completa
        run: dotnet build backend.sln --no-restore --configuration Release

      - name: Instalar ferramentas de cobertura
        run: |
          dotnet add Tests/Tests.csproj package coverlet.collector
          dotnet tool install --global dotnet-reportgenerator-globaltool
          export PATH="$PATH:$HOME/.dotnet/tools"

      - name: Correr testes unitÃ¡rios (xUnit) + Cobertura
        run: |
          mkdir -p TestResults
          echo "ğŸ§ª A testar: Tests/Tests.csproj"
          
          dotnet test Tests/Tests.csproj \
            --no-restore \
            --configuration Release \
            --filter "FullyQualifiedName!~ActivityReminderIntegrationTests" \
            --logger "trx;LogFileName=test-results.trx" \
            --results-directory TestResults \
            --collect:"XPlat Code Coverage" \
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover \
                DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.ExcludeByFile="**/Persistence/**,\
          **/Tests/**,\
          **/Domain/**,\
          **/bin/**,\
          **/obj/**,\
          **/Properties/**,\
          **/*.csproj,\
          **/*.sln,\
          **/*.dcproj,\
          **/*.yml,\
          **/*.yaml,\
          **/*.http,\
          **/Dockerfile,\
          **/docker-compose*,\
          **/Program.cs,\
          **/appsettings*.json,\
          **/.gitignore,\
          **/.dockerignore"
          
          echo ""
          echo "âœ… Testes concluÃ­dos"
          echo ""
          
          # Encontrar e copiar ficheiro de cobertura
          coverage_file=$(find TestResults -name "coverage.*.xml" -type f | head -1)
          if [ -n "$coverage_file" ]; then
            cp "$coverage_file" TestResults/coverage.xml
            echo "âœ… Cobertura encontrada: $coverage_file"
          else
            echo "âš ï¸ Nenhum ficheiro de cobertura encontrado"
            exit 1
          fi
          
          echo ""
          echo "ğŸ“‚ Ficheiros gerados:"
          ls -lah TestResults/

      - name: Verificar se todos os testes passaram
        run: |
          if [ ! -f TestResults/test-results.trx ]; then
            echo "âŒ Ficheiro de resultados nÃ£o encontrado!"
            exit 1
          fi
          
          passed=$(grep -o 'outcome="Passed"' TestResults/test-results.trx | wc -l || echo "0")
          failed=$(grep -o 'outcome="Failed"' TestResults/test-results.trx | wc -l || echo "0")
          total=$((passed + failed))
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“"
          echo "ğŸ“Š RESUMO DOS TESTES UNITÃRIOS"
          echo "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”«"
          echo "   Total: $total"
          echo "   âœ… Passaram: $passed"
          echo "   âŒ Falharam: $failed"
          
          if [ $failed -eq 0 ] && [ $total -gt 0 ]; then
            echo "   ğŸ‰ Todos os testes passaram!"
            echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
          elif [ $failed -gt 0 ]; then
            echo "   âš ï¸  Alguns testes falharam"
            echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
            exit 1
          else
            echo "   âš ï¸  Nenhum teste foi executado"
            echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
            exit 1
          fi

      - name: Gerar relatÃ³rio HTML de cobertura
        if: success()
        run: |
          export PATH="$PATH:$HOME/.dotnet/tools"
          
          if [ -f TestResults/coverage.xml ]; then
            echo "ğŸ“Š A gerar relatÃ³rio HTML de cobertura..."
          
            reportgenerator \
              -reports:TestResults/coverage.xml \
              -targetdir:TestResults/CoverageReport \
              -reporttypes:"Html;HtmlSummary" \
              -verbosity:Info
          
            echo "âœ… RelatÃ³rio HTML gerado em TestResults/CoverageReport/"
            ls -lah TestResults/CoverageReport/
          else
            echo "âš ï¸ Ficheiro de cobertura nÃ£o encontrado. RelatÃ³rio HTML nÃ£o foi gerado."
            exit 1
          fi

      - name: Aplicar Quality Gates personalizadas
        if: success()
        run: |
          if [ ! -f TestResults/coverage.xml ]; then
            echo "âŒ Ficheiro de cobertura nÃ£o encontrado!"
            exit 1
          fi
          
          echo "ğŸ” A analisar cobertura de testes..."
          echo ""
          
          # Extrair cobertura geral do ficheiro XML (formato OpenCover)
          coverage_data=$(cat TestResults/coverage.xml)
          
          # Contar linhas totais e cobertas (excluindo projetos filtrados)
          total_sequences=$(echo "$coverage_data" | grep -oP '<SequencePoint vc="[0-9]+"' | wc -l || echo "0")
          covered_sequences=$(echo "$coverage_data" | grep -oP '<SequencePoint vc="[1-9][0-9]*"' | wc -l || echo "0")
          
          if [ $total_sequences -eq 0 ]; then
            echo "âš ï¸ Nenhuma linha de cÃ³digo encontrada para anÃ¡lise"
            exit 1
          fi
          
          overall_coverage=$((covered_sequences * 100 / total_sequences))
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“"
          echo "  ğŸ“Š COBERTURA DE TESTES"
          echo "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”«"
          echo "  Cobertura geral: ${overall_coverage}%"
          echo "  Linhas cobertas: $covered_sequences/$total_sequences"
          echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
          echo ""
          
          # Obter o tÃ­tulo do Pull Request
          pr_title="${{ github.event.pull_request.title }}"
          
          if [ -z "$pr_title" ]; then
            echo "âš ï¸ Este workflow nÃ£o estÃ¡ a correr num Pull Request"
            echo "   NÃ£o Ã© possÃ­vel determinar a criticidade"
            echo "   A verificar apenas se a cobertura existe..."
            exit 0
          fi
          
          echo "ğŸ“ TÃ­tulo do PR: $pr_title"
          echo ""
          
          # Converter para minÃºsculas para comparaÃ§Ã£o case-insensitive
          pr_title_lower=$(echo "$pr_title" | tr '[:upper:]' '[:lower:]')
          
          # Determinar criticidade baseada no tÃ­tulo do PR
          threshold=0
          criticality=""
          
          if echo "$pr_title_lower" | grep -q "basic"; then
            threshold=40
            criticality="ğŸŸ¢ BASIC"
          elif echo "$pr_title_lower" | grep -q "medium"; then
            threshold=60
            criticality="ğŸŸ¡ MEDIUM"
          elif echo "$pr_title_lower" | grep -q "advanced"; then
            threshold=80
            criticality="ğŸ”´ ADVANCED"
          else
            echo ""
            echo "âš ï¸ Sem quality gate para aplicar - assumindo sucesso"
            exit 0
          fi
          
          echo "ğŸ¯ A aplicar Quality Gate..."
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“"
          echo "  $criticality - Threshold: ${threshold}%"
          echo "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”«"
          
          if [ $overall_coverage -ge $threshold ]; then
            echo "  âœ… PASSOU (${overall_coverage}% â‰¥ ${threshold}%)"
            echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
            echo ""
            echo "âœ… Quality gate passou!"
            exit 0
          else
            echo "  âŒ FALHOU (${overall_coverage}% < ${threshold}%)"
            echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
            echo ""
            echo "âŒ Quality gate falhou!"
            exit 1
          fi

      - name: Exportar resultados de testes e cobertura
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unit-test-results
          path: |
            TestResults/**/*.trx
            TestResults/coverage.xml
            TestResults/CoverageReport/
          if-no-files-found: warn

  # ======================================================
  # 3ï¸âƒ£ INTEGRATION TESTS (POSTMAN CLI)
  # ======================================================
  integration_tests:
    runs-on: ubuntu-latest
    needs: build

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: seepaw
          POSTGRES_PASSWORD: seepaw
          POSTGRES_DB: seepaw_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U seepaw -d seepaw_test"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    env:
      ASPNETCORE_ENVIRONMENT: Docker
      ConnectionStrings__DefaultConnection: "Host=localhost;Port=5432;Database=seepaw_test;Username=seepaw;Password=seepaw"

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Descarregar artefactos do build
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restaurar dependÃªncias
        run: dotnet restore backend.sln

      - name: Compilar projeto
        run: dotnet build backend.sln --no-restore --configuration Release

      - name: Iniciar API em background
        run: |
          echo "ğŸš€ A iniciar a API..."
          dotnet run --project WebAPI/WebAPI.csproj --configuration Release --no-build --urls "http://0.0.0.0:5000" &
          echo $! > server_pid.txt
          echo "â³ A aguardar que a API fique pronta..."
          timeout 60 bash -c '
            until nc -z localhost 5000; do
              echo "Aguardando..."
              sleep 3
          done
          ' || (echo "âŒ A API nÃ£o respondeu a tempo" && exit 1)
          echo "âœ… Porta 5000 estÃ¡ a responder!"
          echo "â³ A aguardar que as migraÃ§Ãµes sejam aplicadas..."
          sleep 15
          echo "âœ… API pronta!"

      - name: Instalar Postman CLI
        run: |
          echo "ğŸ“¦ A instalar Postman CLI..."
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh

      - name: Login no Postman CLI
        run: postman login --with-api-key ${{ secrets.POSTMAN_API_KEY }}
        
      - name: Debug - Listar estrutura do projeto
        run: |
          echo "ğŸ“‚ DiretÃ³rio atual:"
          pwd
          echo ""
          echo "ğŸ“‚ ConteÃºdo da raiz:"
          ls -la
          echo ""
          echo "ğŸ“‚ Verificar se Tests/Assets existe:"
          if [ -d "Tests/Assets" ]; then
            echo "âœ… Tests/Assets encontrado!"
            echo ""
            echo "ğŸ“‚ ConteÃºdo de Tests/Assets:"
            ls -la Tests/Assets/
          else
            echo "âŒ Tests/Assets NÃƒO encontrado!"
            echo ""
            echo "ğŸ” Procurando por Assets em todo o projeto:"
            find . -type d -name "Assets" 2>/dev/null || echo "Nenhum diretÃ³rio Assets encontrado"
          fi

      - name: Prepare Postman working directory
        run: |
          mkdir -p ~/Postman/files

          # Verificar se os ficheiros existem antes de copiar
          if [ -d "Tests/Assets" ] && [ "$(ls -A Tests/Assets 2>/dev/null)" ]; then
            echo "âœ… A copiar ficheiros de Tests/Assets/ para ~/Postman/files/"
            cp -v Tests/Assets/* ~/Postman/files/ || {
              echo "âŒ Erro ao copiar ficheiros!"
              echo "ğŸ” ConteÃºdo de Tests/Assets:"
              ls -la Tests/Assets/
              exit 1
            }
          else
            echo "âš ï¸ Tests/Assets nÃ£o existe ou estÃ¡ vazio"
            echo "ğŸ” Procurando por ficheiros de teste..."

            # Tentar caminhos alternativos
            if [ -d "backend/Tests/Assets" ]; then
              echo "âœ… Encontrado em backend/Tests/Assets/"
              cp -v backend/Tests/Assets/* ~/Postman/files/
            elif [ -d "../Tests/Assets" ]; then
              echo "âœ… Encontrado em ../Tests/Assets/"
              cp -v ../Tests/Assets/* ~/Postman/files/
            else
              echo "âŒ NÃ£o foi possÃ­vel encontrar os ficheiros de teste!"
              echo "ğŸ“‚ Estrutura do projeto:"
              find . -name "Assets" -type d
              exit 1
            fi
          fi

      - name: List Postman working dir
        run: |
          echo "ğŸ“‚ ConteÃºdo de ~/Postman/files:"
          ls -lah ~/Postman/files/ || echo "âš ï¸ DiretÃ³rio vazio ou nÃ£o existe"

      - name: Executar testes Postman e gerar relatÃ³rios
        run: |
          set -e
          
          mkdir -p TestResults/postman
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“"
          echo "ğŸ§ª TESTES DE INTEGRAÃ‡ÃƒO - POSTMAN"
          echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
          echo ""
          
          # Executar a coleÃ§Ã£o "Tests" usando o Postman CLI
          # NOTA: Postman CLI suporta apenas: cli, json, junit, html (bÃ¡sico)
          postman collection run "${{ secrets.POSTMAN_COLLECTION_ID }}" \
          -e "${{ secrets.POSTMAN_ENV_ID }}" \
          --env-var "url=http://localhost:5000" \
          --working-dir ~/Postman/files \
          --reporters cli,json,html \
          --reporter-json-export TestResults/postman/results.json \
          --reporter-html-export TestResults/postman/report.html \
          --delay-request 300 \
          --timeout-request 10000 \
          --bail false \
          --color on \
          2>&1 | tee TestResults/postman/console-output.txt
          
          exit_code=${PIPESTATUS[0]}
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Processar resultados
          if [ -f TestResults/postman/results.json ]; then
            total=$(jq -r '.run.stats.assertions.total // 0' TestResults/postman/results.json)
            failed=$(jq -r '.run.stats.assertions.failed // 0' TestResults/postman/results.json)
            passed=$((total - failed))
          
            echo "ğŸ“Š RESUMO DOS TESTES:"
            echo "   Total: $total"
            echo "   âœ… Passaram: $passed"
            echo "   âŒ Falharam: $failed"
          
            if [ $failed -gt 0 ]; then
              echo ""
              echo "âš ï¸  Alguns testes falharam!"
              echo "ğŸ“„ Consulta o relatÃ³rio HTML para mais detalhes"
            else
              echo ""
              echo "ğŸ‰ Todos os testes passaram!"
            fi
          
            # Criar resumo em JSON
            cat > TestResults/postman/summary.json <<EOF
          {
            "total": $total,
            "passed": $passed,
            "failed": $failed,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": $([ $failed -eq 0 ] && echo '"PASS"' || echo '"FAIL"')
          }
          EOF
          else
            echo "âŒ Erro: Ficheiro de resultados nÃ£o foi gerado"
            exit 1
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Retornar o exit code original do Postman CLI
          exit $exit_code

      - name: Upload resultados de integraÃ§Ã£o
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            TestResults/postman/**
          if-no-files-found: warn

      - name: Publicar relatÃ³rio HTML como comentÃ¡rio no PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let summary = { total: 0, passed: 0, failed: 0, status: 'UNKNOWN' };
            
            try {
              const summaryFile = 'TestResults/postman/summary.json';
              if (fs.existsSync(summaryFile)) {
                summary = JSON.parse(fs.readFileSync(summaryFile, 'utf8'));
              }
            } catch (error) {
              console.error('Erro ao ler resumo:', error);
            }
            
            const emoji = summary.status === 'PASS' ? 'âœ…' : 'âŒ';
            const statusText = summary.status === 'PASS' ? 'PASSOU' : 'FALHOU';
            
            const comment = `
            ## ${emoji} Testes de IntegraÃ§Ã£o (Postman) - ${statusText}
            
            **Resumo:**
            - ğŸ§ª Total de testes: ${summary.total}
            - âœ… Passaram: ${summary.passed}
            - âŒ Falharam: ${summary.failed}
            
            ğŸ“„ **RelatÃ³rio HTML completo disponÃ­vel nos artefactos desta execuÃ§Ã£o.**
            
            Para visualizar o relatÃ³rio detalhado:
            1. Vai aos artefactos desta workflow run
            2. Descarrega \`integration-test-results\`
            3. Abre o ficheiro \`report.html\` no browser
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Parar API e containers
        if: always()
        run: |
          echo "ğŸ§¹ A encerrar ambiente de teste..."
          kill $(cat server_pid.txt) || true
          
# ======================================================
# INTEGRATION TESTS WITH DATABASE
# ======================================================
  integration_tests_db:
    runs-on: ubuntu-latest
    needs: build
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: seepaw
          POSTGRES_PASSWORD: seepawpwd
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restaurar dependÃªncias
        run: dotnet restore backend.sln

      - name: Compilar soluÃ§Ã£o
        run: dotnet build backend.sln --no-restore --configuration Release

      - name: Correr testes de integraÃ§Ã£o com BD
        run: |
          echo "ğŸ—„ï¸ A correr testes de integraÃ§Ã£o com PostgreSQL..."
          
          dotnet test Tests/Tests.csproj \
            --no-restore \
            --configuration Release \
            --filter "FullyQualifiedName~ActivityReminderIntegrationTests" \
            --logger "trx;LogFileName=integration-db-results.trx" \
            --results-directory TestResults
          
          echo "âœ… Testes de integraÃ§Ã£o concluÃ­dos"

      - name: Verificar resultados
        if: always()
        run: |
          if [ -f TestResults/integration-db-results.trx ]; then
            passed=$(grep -o 'outcome="Passed"' TestResults/integration-db-results.trx | wc -l || echo "0")
            failed=$(grep -o 'outcome="Failed"' TestResults/integration-db-results.trx | wc -l || echo "0")
            skipped=$(grep -o 'outcome="NotExecuted"' TestResults/integration-db-results.trx | wc -l || echo "0")
            total=$((passed + failed + skipped))
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“"
            echo "ğŸ“Š TESTES DE INTEGRAÃ‡ÃƒO COM BD"
            echo "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”«"
            echo "   Total: $total"
            echo "   âœ… Passaram: $passed"
            echo "   âŒ Falharam: $failed"
            echo "   â­ï¸  Saltados: $skipped"
            
            if [ $failed -eq 0 ] && [ $total -gt 0 ]; then
              echo "   ğŸ‰ Todos os testes passaram!"
              echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
            elif [ $failed -gt 0 ]; then
              echo "   âš ï¸  Alguns testes falharam"
              echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
              exit 1
            else
              echo "   âš ï¸  Nenhum teste foi executado"
              echo "â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›"
              exit 1
            fi
          else
            echo "âŒ Ficheiro de resultados nÃ£o encontrado!"
            exit 1
          fi

      - name: Upload resultados de integraÃ§Ã£o com BD
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-db-test-results
          path: TestResults/
          if-no-files-found: warn